package filter

import (
	"strconv"
)

// EnumStr 仅允许allows中的值
func (strType *StringType) EnumStr(allows []string, customError ...string) *StringType {
	if strType.err != nil || strType.currentValue == "" {
		return strType
	}
	for k := range allows {
		if allows[k] == strType.currentValue {
			return strType
		}
	}
	strType.err = wrapError(strType.name, InvalidErrorText, customError...)
	return strType
}

// EnumInt 仅允许allows中的值
func (strType *StringType) EnumInt(allows []int, customError ...string) *StringType {
	if strType.err != nil || strType.currentValue == "" {
		return strType
	}
	value, err := strconv.Atoi(strType.currentValue)
	if err != nil {
		strType.err = wrapError(strType.name, InvalidErrorText, customError...)
		return strType
	}
	for k := range allows {
		if value == allows[k] {
			return strType
		}
	}
	strType.err = wrapError(strType.name, InvalidErrorText, customError...)
	return strType
}

// EnumInt8 仅允许allows中的值
func (strType *StringType) EnumInt8(allows []int8, customError ...string) *StringType {
	if strType.err != nil || strType.currentValue == "" {
		return strType
	}
	value64, err := strconv.ParseInt(strType.currentValue, 10, 8)
	if err != nil {
		strType.err = wrapError(strType.name, InvalidErrorText, customError...)
		return strType
	}
	value := int8(value64)
	for k := range allows {
		if value == allows[k] {
			return strType
		}
	}
	strType.err = wrapError(strType.name, InvalidErrorText, customError...)
	return strType
}

// EnumInt16 仅允许allows中的值
func (strType *StringType) EnumInt16(allows []int16, customError ...string) *StringType {
	if strType.err != nil || strType.currentValue == "" {
		return strType
	}
	value64, err := strconv.ParseInt(strType.currentValue, 10, 16)
	if err != nil {
		strType.err = wrapError(strType.name, InvalidErrorText, customError...)
		return strType
	}
	value := int16(value64)
	for k := range allows {
		if value == allows[k] {
			return strType
		}
	}
	strType.err = wrapError(strType.name, InvalidErrorText, customError...)
	return strType
}

// EnumInt32 仅允许allows中的值
func (strType *StringType) EnumInt32(allows []int32, customError ...string) *StringType {
	if strType.err != nil || strType.currentValue == "" {
		return strType
	}
	value64, err := strconv.ParseInt(strType.currentValue, 10, 32)
	if err != nil {
		strType.err = wrapError(strType.name, InvalidErrorText, customError...)
		return strType
	}
	value32 := int32(value64)
	for k := range allows {
		if value32 == allows[k] {
			return strType
		}
	}
	strType.err = wrapError(strType.name, InvalidErrorText, customError...)
	return strType
}

// EnumInt64 仅允许allows中的值
func (strType *StringType) EnumInt64(allows []int64, customError ...string) *StringType {
	if strType.err != nil || strType.currentValue == "" {
		return strType
	}
	value64, err := strconv.ParseInt(strType.currentValue, 10, 64)
	if err != nil {
		strType.err = wrapError(strType.name, InvalidErrorText, customError...)
		return strType
	}
	for k := range allows {
		if value64 == allows[k] {
			return strType
		}
	}
	strType.err = wrapError(strType.name, InvalidErrorText, customError...)
	return strType
}

// EnumFloat32 仅允许allows中的值
func (strType *StringType) EnumFloat32(allows []float32, customError ...string) *StringType {
	if strType.err != nil || strType.currentValue == "" {
		return strType
	}
	value, err := strconv.ParseFloat(strType.currentValue, 32)
	if err != nil {
		strType.err = wrapError(strType.name, InvalidErrorText, customError...)
		return strType
	}
	value32 := float32(value)
	for k := range allows {
		if value32 == allows[k] {
			return strType
		}
	}
	strType.err = wrapError(strType.name, InvalidErrorText, customError...)
	return strType
}

// EnumFloat64 仅允许allows中的值
func (strType *StringType) EnumFloat64(allows []float64, customError ...string) *StringType {
	if strType.err != nil || strType.currentValue == "" {
		return strType
	}
	value64, err := strconv.ParseFloat(strType.currentValue, 64)
	if err != nil {
		strType.err = wrapError(strType.name, InvalidErrorText, customError...)
		return strType
	}
	for k := range allows {
		if value64 == allows[k] {
			return strType
		}
	}
	strType.err = wrapError(strType.name, InvalidErrorText, customError...)
	return strType
}

// EnumStrSlice 仅允许使用allows中的值
func (strType *StringType) EnumStrSlice(sep string, allows []string, trimSpace bool, customError ...string) *StringType {
	if strType.err != nil || strType.currentValue == "" {
		return strType
	}
	values, err := strType.SliceString(sep, trimSpace)
	if err != nil {
		strType.err = wrapError(strType.name, InvalidErrorText, customError...)
		return strType
	}
	for k := range values {
		if !inStrings(values[k], allows) {
			strType.err = wrapError(strType.name, InvalidErrorText, customError...)
			return strType
		}
	}
	return strType
}

// EnumIntSlice 仅允许使用allows中的值
func (strType *StringType) EnumIntSlice(sep string, allows []int, trimSpace bool, customError ...string) *StringType {
	if strType.err != nil || strType.currentValue == "" {
		return strType
	}
	values, err := strType.SliceString(sep, trimSpace)
	if err != nil {
		strType.err = wrapError(strType.name, InvalidErrorText, customError...)
		return strType
	}
	for k := range values {
		v, err := strconv.Atoi(values[k])
		if err != nil {
			strType.err = wrapError(strType.name, InvalidErrorText, customError...)
			return strType
		}
		if !inInt(v, allows) {
			strType.err = wrapError(strType.name, InvalidErrorText, customError...)
			return strType
		}
	}
	strType.err = wrapError(strType.name, InvalidErrorText, customError...)
	return strType
}

func inStrings(v string, s []string) bool {
	for k := range s {
		if s[k] == v {
			return true
		}
	}
	return false
}

func inInt(v int, s []int) bool {
	for k := range s {
		if s[k] == v {
			return true
		}
	}
	return false
}
