package filter

import (
	"errors"
	"reflect"
)

func (strType *StringType) setCheck(target interface{}) (*reflect.Value, error) {
	if strType.err != nil {
		return nil, strType.err
	}

	// 检查目标是否为nil
	if target == nil {
		return nil, errors.New("the assignment target cannot be a null pointer")
	}

	targetValueOf := reflect.ValueOf(target)
	// 检查对象是否是指针
	if targetValueOf.Kind() != reflect.Ptr {
		return nil, errors.New("the assignment target must be a pointer")
	}
	// 检查对象是否能赋值
	if !targetValueOf.Elem().CanSet() {
		return nil, errors.New("cannot assign to the target")
	}
	return &targetValueOf, nil
}

// 赋值到普通对象
func (strType *StringType) Set(target interface{}, customError ...string) error {
	targetValueOf, err := strType.setCheck(target)
	if err != nil {
		return strType.err
	}

	// 开始赋值
	targetTypeOf := targetValueOf.Elem().Type().Kind()
	switch targetTypeOf { //nolint
	case reflect.String:
		targetValueOf.Elem().SetString(strType.currentValue)
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		value, err := strType.Int64()
		if err != nil {
			return strType.err
		}
		if targetValueOf.Elem().OverflowInt(value) {
			strType.err = wrapError(strType.name, InvalidErrorText, customError...)
			return strType.err
		}
		targetValueOf.Elem().SetInt(value)
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		value, err := strType.Uint64()
		if err != nil {
			return strType.err
		}
		if targetValueOf.Elem().OverflowUint(value) {
			strType.err = wrapError(strType.name, InvalidErrorText, customError...)
			return strType.err
		}
		targetValueOf.Elem().SetUint(value)
	case reflect.Float32, reflect.Float64:
		value, err := strType.Float64()
		if err != nil {
			return strType.err
		}
		if targetValueOf.Elem().OverflowFloat(value) {
			strType.err = wrapError(strType.name, InvalidErrorText, customError...)
			return strType.err
		}
		targetValueOf.Elem().SetFloat(value)
	case reflect.Bool:
		value, err := strType.Bool()
		if err != nil {
			return strType.err
		}
		targetValueOf.Elem().SetBool(value)
	case reflect.Slice:
		return errors.New("the '" + targetTypeOf.String() + "' type must be assigned using the 'SetSlice' method")
	default:
		strType.err = wrapError(strType.name, "Cannot assign to the '"+targetTypeOf.String()+"' type")
		return strType.err
	}
	return nil
}

func (strType *StringType) SetSlice(target interface{}, sep string, trimSpace bool, customError ...string) error {
	if sep == "" {
		strType.err = wrapError(strType.name, "`sep`parameter cannot be empty", customError...)
		return strType.err
	}
	targetValueOf, err := strType.setCheck(target)
	if err != nil {
		strType.err = wrapError(strType.name, err.Error(), customError...)
		return strType.err
	}

	// 检查对象是否是指针
	if targetValueOf.Kind() != reflect.Ptr {
		strType.err = wrapError(strType.name, "the assignment target must be a pointer", customError...)
		return strType.err
	}
	// 检查对象是否能赋值
	if !targetValueOf.Elem().CanSet() {
		strType.err = wrapError(strType.name, "cannot assign to the target", customError...)
		return strType.err
	}

	// 如果不是slice类型则调用set
	targetTypeOf := targetValueOf.Elem().Type().Kind()
	if targetTypeOf != reflect.Slice {
		return strType.Set(target, customError...)
	}

	// 开始赋值
	sliceType := targetValueOf.Elem().Type().String()
	switch sliceType {
	case "[]string":
		value, err := strType.SliceString(sep, trimSpace)
		if err != nil {
			return strType.err
		}
		targetValueOf.Elem().Set(reflect.ValueOf(value))
	case "[]int":
		value, err := strType.SliceInt(sep)
		if err != nil {
			return strType.err
		}
		targetValueOf.Elem().Set(reflect.ValueOf(value))
	case "[]int8":
		value, err := strType.SliceInt8(sep)
		if err != nil {
			return strType.err
		}
		targetValueOf.Elem().Set(reflect.ValueOf(value))
	case "[]int16":
		value, err := strType.SliceInt16(sep)
		if err != nil {
			return strType.err
		}
		targetValueOf.Elem().Set(reflect.ValueOf(value))
	case "[]int32":
		value, err := strType.SliceInt32(sep)
		if err != nil {
			return strType.err
		}
		targetValueOf.Elem().Set(reflect.ValueOf(value))
	case "[]int64":
		value, err := strType.SliceInt64(sep)
		if err != nil {
			return strType.err
		}
		targetValueOf.Elem().Set(reflect.ValueOf(value))
	case "[]uint":
		value, err := strType.SliceUint(sep)
		if err != nil {
			return strType.err
		}
		targetValueOf.Elem().Set(reflect.ValueOf(value))
	case "[]uint8":
		value, err := strType.SliceUint8(sep)
		if err != nil {
			return strType.err
		}
		targetValueOf.Elem().Set(reflect.ValueOf(value))
	case "[]uint16":
		value, err := strType.SliceUint16(sep)
		if err != nil {
			return strType.err
		}
		targetValueOf.Elem().Set(reflect.ValueOf(value))
	case "[]uint32":
		value, err := strType.SliceUint32(sep)
		if err != nil {
			return strType.err
		}
		targetValueOf.Elem().Set(reflect.ValueOf(value))
	case "[]uint64":
		value, err := strType.SliceUint64(sep)
		if err != nil {
			return strType.err
		}
		targetValueOf.Elem().Set(reflect.ValueOf(value))
	case "[]float32":
		value, err := strType.SliceFloat32(sep)
		if err != nil {
			return strType.err
		}
		targetValueOf.Elem().Set(reflect.ValueOf(value))
	case "[]float64":
		value, err := strType.SliceFloat64(sep)
		if err != nil {
			return strType.err
		}
		targetValueOf.Elem().Set(reflect.ValueOf(value))
	case "[]bool":
		value, err := strType.SliceBool(sep)
		if err != nil {
			return strType.err
		}
		targetValueOf.Elem().Set(reflect.ValueOf(value))
	default:
		strType.err = wrapError(strType.name, "Cannot assign to the '"+sliceType+"' type")
		return strType.err
	}
	return nil
}
